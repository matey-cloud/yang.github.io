<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>eliauk</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-16T07:25:06.644Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>new C++</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/08/16/%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2023/08/16/%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2023-08-16T07:33:46.811Z</published>
    <updated>2023-08-16T07:25:06.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列式容器分类"><a href="#序列式容器分类" class="headerlink" title="序列式容器分类"></a>序列式容器分类</h2><p><img src="https://s2.loli.net/2023/08/16/ybceWa2J5nRQkqH.png" alt="SGI_STL各种容器.png"></p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h4 id="1-采用线性连续空间"><a href="#1-采用线性连续空间" class="headerlink" title="1.采用线性连续空间"></a>1.采用线性连续空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">iterator start; <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">iterator finish；<span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">iterator end_of_storage;<span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-vector元素操作：pop-back-erase-clear-insert"><a href="#2-vector元素操作：pop-back-erase-clear-insert" class="headerlink" title="2.vector元素操作：pop_back, erase, clear, insert"></a>2.vector元素操作：pop_back, erase, clear, insert</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123; <span class="comment">// 拿掉尾端元素，并调整大小</span></span><br><span class="line">--finish;</span><br><span class="line"><span class="built_in">destroy</span>(finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将last迭代器和finish迭代器之间的元素复制到first迭代器开始的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>&#123;</span><br><span class="line"><span class="comment">// copy是全局函数,将[last, finish)范围的元素复制到first开始的位置，并返回目标范围的末尾迭代器。</span></span><br><span class="line">iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line"><span class="built_in">destroy</span>(i, finish);</span><br><span class="line">finish = finish - (last - first);</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除某个位置上的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);</span><br><span class="line">    --finish;</span><br><span class="line">    <span class="built_in">destory</span>(finish);</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> vector&lt;T,Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x)&#123;</span><br><span class="line"><span class="keyword">if</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n)&#123;</span><br><span class="line"><span class="comment">// 备用空间足够（大于 新增元素个数）</span></span><br><span class="line">T x_copy = x;</span><br><span class="line"><span class="type">const</span> size_type elems_after = finish - position;</span><br><span class="line">iterator old_finish = finish;</span><br><span class="line"><span class="keyword">if</span>(elems_after &gt; n)&#123;</span><br><span class="line"><span class="comment">//插入点之后的现有元素个数 大于 新增元素个数</span></span><br><span class="line">                <span class="built_in">uninitialized_copy</span>(finish-n, finish, finish);</span><br><span class="line">                finish += n; <span class="comment">// 将vector尾端标记后移</span></span><br><span class="line">                <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);<span class="comment">// 将插入点之后的元素后移</span></span><br><span class="line">                <span class="built_in">fill</span>(position, position + n, x_copy); <span class="comment">// 从插入点开始填入新值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 插入点之后的现有元素个数 小于 新增元素个数</span></span><br><span class="line">                <span class="built_in">uninitialized_fill_n</span>(finish, n-elems_after, x_copy);</span><br><span class="line">                finish += n - elems_after;</span><br><span class="line">                <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">                finish += elems_after;</span><br><span class="line">                <span class="built_in">fill</span>(position, old_finish, x_copy);   </span><br><span class="line">            &#125;               </span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 备用空间小于 新增元素个数，需要配置额外的内存</span></span><br><span class="line">            <span class="comment">// 决定新长度，1旧长度的两倍，2旧长度加新增元素个数</span></span><br><span class="line">            <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">            <span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">            <span class="comment">// 配置新的vector空间</span></span><br><span class="line">            iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">            iterator new_finish = new_start;</span><br><span class="line">            __STL_TRY&#123;</span><br><span class="line">                <span class="comment">// 首先将旧vector的插入点之前的元素复制到新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">                <span class="comment">// 再将新增元素（初值皆为n）填入新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">                <span class="comment">// 再将旧vector插入点之后的元素复制到新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 清除并释放旧的vector</span></span><br><span class="line">            <span class="built_in">destory</span>(start, finish);</span><br><span class="line">            <span class="built_in">deallcoate</span>();</span><br><span class="line">            <span class="comment">// 调整水位标记</span></span><br><span class="line">            start = new_start;</span><br><span class="line">            finish = new_finish;</span><br><span class="line">            end_of_storage = new_start + len;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h4 id="1-list的节点node"><a href="#1-list的节点node" class="headerlink" title="1.list的节点node"></a>1.list的节点node</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev; <span class="comment">// 型别为void*,也可设为__list_node&lt;T&gt;*</span></span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-list迭代器"><a href="#2-list迭代器" class="headerlink" title="2.list迭代器"></a>2.list迭代器</h4><p>​list的节点不保证存储再连续空间中，list迭代器必须能够指向list的节点，并且能够正确的递增、递减、取值、成员存取等操作</p><p>​list插入操作（insert）和结合操作（splice）都不会造成原有的迭代器失效。erase操作只有 指向被删除元素 的那个迭代器失效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">// 指向节点的指针类型</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;   <span class="comment">// 当前迭代器类的别名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    </span><br><span class="line">    link_type node; <span class="comment">// 迭代器内部需要一个普通指针，指向list的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// constrcutor</span></span><br><span class="line">    __list_iterator(link_type x) : <span class="built_in">node</span>(x)&#123;&#125;</span><br><span class="line">    __list_iterator() &#123;&#125;</span><br><span class="line">    __list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node==x.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node!=x.node; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对迭代器取值，取的是节点的数据值</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    </span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() cosnt &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        node = (link_type)((*node).next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">        node = (link_type)((*node).prev);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-list的元素操作"><a href="#3-list的元素操作" class="headerlink" title="3.list的元素操作"></a>3.list的元素操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert：在迭代器position所指位置插入一个节点，内容为x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">link_type tmp = <span class="built_in">create_node</span>(x);</span><br><span class="line">    tmp-&gt;next = position.node;</span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">    </span><br><span class="line">    (<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">    position.node-&gt;prev = tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（1）插入操作push-front和push-back，移除操作erase"><a href="#（1）插入操作push-front和push-back，移除操作erase" class="headerlink" title="（1）插入操作push_front和push_back，移除操作erase"></a>（1）插入操作push_front和push_back，移除操作erase</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个节点，作为头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x); &#125;</span><br><span class="line"><span class="comment">// 插入一个节点，作为尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除迭代器position所指节点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">link_type next_node = <span class="built_in">link_type</span>(position.node-&gt;next);</span><br><span class="line">    link_type prev_node = <span class="built_in">link_type</span>(position.node-&gt;prev);</span><br><span class="line">    </span><br><span class="line">    prev_node-&gt;next = next_node;</span><br><span class="line">    next_node-&gt;prev = prev_node;</span><br><span class="line">    <span class="built_in">destory_node</span>(position.node);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="comment">//移除尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    iterator tmp = <span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">erase</span>(--tmp); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    link_type cur = (link_type)node-&gt;next; <span class="comment">// begin()</span></span><br><span class="line">    <span class="keyword">while</span>(cur != node)&#123; <span class="comment">// 遍历每个节点</span></span><br><span class="line">        link_type tmp = cur;</span><br><span class="line">        cur = (link_type) cur-&gt;next;</span><br><span class="line">        <span class="built_in">destory_node</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复node原始状态</span></span><br><span class="line">    node-&gt;next = node;</span><br><span class="line">    node-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值为value的所有元素移除</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value)&#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">        iterator next = first;</span><br><span class="line">        ++next;</span><br><span class="line">        <span class="keyword">if</span>(*first == value)</span><br><span class="line">            <span class="built_in">erase</span>(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除数值相同的连续元素， 只有 连续且相同的元素 才会被移除剩一个</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>()&#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">if</span>(first == last) <span class="keyword">return</span>;</span><br><span class="line">    iterator next = first;</span><br><span class="line">    <span class="keyword">while</span>(++next != last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*first == *next)</span><br><span class="line">            <span class="built_in">erase</span>(next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first = next;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）迁移操作（transfer）"><a href="#（2）迁移操作（transfer）" class="headerlink" title="（2）迁移操作（transfer）"></a>（2）迁移操作（transfer）</h5><p>将某连续范围的元素迁移到某个特定位置之前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//将[first, last)内的所有元素移动到position之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( position != last)&#123;</span><br><span class="line">        (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node;</span><br><span class="line">        (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node;</span><br><span class="line">        (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node;</span><br><span class="line">        link_type tmp = <span class="built_in">link_type</span>((*position.node).prev);</span><br><span class="line">        (*position.node).prev = (*last.node).prev;</span><br><span class="line">        (*last.node).prev = (*first.node).prev;</span><br><span class="line">        (*first.node).prev = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="（3）接合操作splice"><a href="#（3）接合操作splice" class="headerlink" title="（3）接合操作splice"></a>（3）接合操作splice</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 将x接合于position所指位置之前，x必须不同于*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将i所指元素接合于position所指位置之前，position和i可指向同一个list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; , iterator i)</span></span>&#123;</span><br><span class="line">        iterator j = i;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span>(position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">transfer</span>(position, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[first, last)内的所有元素接合于position所指位置之前</span></span><br><span class="line"><span class="comment">// position和[first, last)可指向同一个list</span></span><br><span class="line"><span class="comment">// 但position不能位于[first, last)内</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first != last)</span><br><span class="line">            <span class="built_in">transfer</span>(position, first, last);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="（4）merge、reverse、sort"><a href="#（4）merge、reverse、sort" class="headerlink" title="（4）merge、reverse、sort"></a>（4）merge、reverse、sort</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge()将x合并到*this上，两个list的内容必须先经过递增排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x)&#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator end2 = x.<span class="built_in">end</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并前，两个容器必须已经递增排序</span></span><br><span class="line">    <span class="keyword">while</span>(first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">        <span class="keyword">if</span>(*first2 &lt; first1)&#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            ++first1;</span><br><span class="line">    <span class="keyword">if</span>(first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverse() 将*this的内容重置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>()&#123;</span><br><span class="line">    <span class="comment">// 也可用size() == 0 和 size() == 1判断，但是效率慢</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="built_in">end</span>())&#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++first;</span><br><span class="line">        <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>()&#123;</span><br><span class="line"><span class="comment">// 也可用size() == 0 和 size() == 1判断，但是效率慢</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 一些新的lists作为中介数据存放区</span></span><br><span class="line">    list&lt;T, Alloc&gt; carry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个counter[i]最多储存2^i个元素</span></span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">empty</span>())&#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());<span class="comment">//1</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);<span class="comment">//2</span></span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]);<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">if</span>(i == fill)<span class="comment">//5</span></span><br><span class="line">            ++fill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i)</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);<span class="comment">//6</span></span><br><span class="line">    <span class="built_in">swap</span>(counter[fill - <span class="number">1</span>]);<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始状态</p><p><img src="https://s2.loli.net/2023/08/15/wvghVy2SD456ATY.png" alt="STL_list排序初始状态.png"></p><p>第一次循环</p><p><img src="https://s2.loli.net/2023/08/15/BwgjPaonKEVps3e.png" alt="STL_list排序第一次循环.png"></p><p>第二次循环</p><p><img src="https://s2.loli.net/2023/08/15/5xmvbLgAD7hSlPr.png" alt="STL_list排序第二次循环.png"></p><p>第三次循环</p><p><img src="https://s2.loli.net/2023/08/15/H7PFUqmKLwIEBnb.png" alt="STL_list排序第三次循环.png"></p><p>第四次循环</p><p><img src="https://s2.loli.net/2023/08/15/X2lU9PW4SqRxQ3e.png" alt="STL_list排序第四次循环.png"></p><p>跳出循环</p><p><img src="https://s2.loli.net/2023/08/15/cxtGe8XBpLYMZRo.png" alt="STL_list排序跳出循环.png"></p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​vector是单向开口的连续线性空间，deque是双向开口的连续线性空间。vector也可以在头尾两端进行操作，但是头部操作效率很差</p><p>​deque采用一块所谓的map作为主控，是一小块连续空间，其中每个元素（称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区</p><h4 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h4><p>​（1）需要能够指出分段连续空间在哪里</p><p>​（2）能够判断自己是否处于缓冲区边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区，为了保证正确跳跃，deque需要随时掌握map（管控中心）</p><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保持与容器的联结</span></span><br><span class="line">T* cur; <span class="comment">//指向缓冲区现行(current)元素</span></span><br><span class="line">T* first; <span class="comment">//指向缓冲区的头</span></span><br><span class="line">T* last; <span class="comment">//指向缓冲区的尾(含备用空间)</span></span><br><span class="line">map_pointer node; <span class="comment">//指向管控中心map</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/15/oTuQ9HS7jNrWUx1.png" alt="STL_deque迭代器.png"></p><h5 id="set-node-跳一个缓冲区"><a href="#set-node-跳一个缓冲区" class="headerlink" title="set_node()跳一个缓冲区"></a>set_node()跳一个缓冲区</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span></span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">different_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++()&#123; <span class="comment">// 前置式</span></span><br><span class="line">    ++cur;</span><br><span class="line">    <span class="keyword">if</span>(cur == last)&#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node+<span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 后置＋＋</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == first)&#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node<span class="number">-1</span>);</span><br><span class="line">        cur = last;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现随机存取，迭代器可以直接跳跃n个距离</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n)&#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span>(offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">        <span class="comment">// 目标在同一缓冲区中</span></span><br><span class="line">        cur+=n;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 目标不在同一缓冲区中</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset/<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">             : -<span class="built_in">difference_type</span>((-offset<span class="number">-1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换到正确的节点（缓冲区）中</span></span><br><span class="line">        <span class="built_in">set_node</span>(node+node_offset);</span><br><span class="line">        cur = first+(offset- node_offset*<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>+=(-n); &#125;</span><br><span class="line">self&amp; <span class="keyword">operator</span>-(difference_type n) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现随机存取，迭代器可以直接跳跃n个距离</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (node==x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h4><h5 id="deque的数据结构-1"><a href="#deque的数据结构-1" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要指定每个缓冲区的大小BufSiz 默认值为0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 元素的指针的指针</span></span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">    </span><br><span class="line">    iterator start; <span class="comment">//第一个节点</span></span><br><span class="line">    iterator finish;<span class="comment">//最后一个节点</span></span><br><span class="line">    map_pointer map;<span class="comment">// 指向map，map是块连续空间，每个元素都是指针，指向一个节点</span></span><br><span class="line">    size_type map_size; <span class="comment">//map中有多少个指针</span></span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n)&#123;</span><br><span class="line">        <span class="comment">// 调用__deque_iterator&lt;&gt;::operator[]</span></span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> *tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 下行两个‘;’，合乎语法</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> finish - start;; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure><h4 id="deque构造和内存管理"><a href="#deque构造和内存管理" class="headerlink" title="deque构造和内存管理"></a>deque构造和内存管理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">: <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fill-initialize"><a href="#fill-initialize" class="headerlink" title="fill_initialize()"></a>fill_initialize()</h5><p>负责构建deque的结构，并将元素的初值设定妥当</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="type">const</span> value_type&amp; value)&#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n);</span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY&#123;</span><br><span class="line">        <span class="comment">// 为每个节点的缓冲区设定初值</span></span><br><span class="line">        <span class="keyword">for</span>(cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur+<span class="built_in">buffer_size</span>(), value);</span><br><span class="line">        <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="create-map-and-nodes"><a href="#create-map-and-nodes" class="headerlink" title="create_map_and_nodes()"></a>create_map_and_nodes()</h5><p>负责构建deque的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements)&#123;</span><br><span class="line">    <span class="comment">// 需要节点数=（元素个数/每个缓冲区可容纳的元素个数）+1</span></span><br><span class="line">    <span class="comment">// 如果刚好整除，会多分配一个节点</span></span><br><span class="line">    size_type num_nodes = num_elements/<span class="built_in">buffer_size</span>()+<span class="number">1</span>; <span class="comment">// 若缓冲区大小为32bytes，</span></span><br><span class="line">    <span class="comment">// 当传入20个int数据，num_nodes = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个map要管理几个节点。最少8个， 最多是“所需节点数加2”</span></span><br><span class="line">    <span class="comment">// （前后各预留一个，扩充时可用）</span></span><br><span class="line">    map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);     <span class="comment">// 8</span></span><br><span class="line">    map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 令nstart和nfinish指向map所拥有全部节点的最中央区段</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾扩充的空间一样大，每个节点可对应一个缓冲区</span></span><br><span class="line">    map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>; <span class="comment">// map + 2</span></span><br><span class="line">    map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;    <span class="comment">// map + 4</span></span><br><span class="line">    </span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY&#123;</span><br><span class="line">        <span class="comment">// 为map内的每个现有节点配置缓冲区，所有缓冲区加起来就是deque的可用空间</span></span><br><span class="line">        <span class="keyword">for</span>(cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为deque内的两个迭代器start和end设置正确内容</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    finish.cur = finish.first + num_elements%<span class="built_in">buffer_size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(finish.cur != finish.last - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t);</span><br><span class="line">        ++finish.cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">// 最后缓冲区已无或者只剩一个元素备用空间</span></span><br><span class="line">        <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.last - 1时才会被调用</span></span><br><span class="line"><span class="comment">// 只有当最后一个缓冲区只剩一个备用空间时才会调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t)&#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_back</span>(); <span class="comment">// 若符合某种条件必须重换一个map</span></span><br><span class="line">    *(finish.node+<span class="number">1</span>) = <span class="built_in">allocate_node</span>(); <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    __STL_TRY&#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t_copy);</span><br><span class="line">        finish.<span class="built_in">set_node</span>(finish.node+<span class="number">1</span>);</span><br><span class="line">        finish.cur = finish.first;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">        <span class="comment">// 如果map尾端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件则必须重换一个map（配置更大的，拷贝原来的，释放原来的</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="push-front"><a href="#push-front" class="headerlink" title="push_front()"></a>push_front()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start.cur != start.first)&#123;</span><br><span class="line">        <span class="comment">// 第一缓冲区尚有备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(start.cur<span class="number">-1</span>, t);</span><br><span class="line">        --start.cur;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有start.cur == start.first时才会调用</span></span><br><span class="line"><span class="comment">// 只有第一个缓冲区没有备用元素时才会被调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc. BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> valus_type&amp; t)&#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_front</span>(); <span class="comment">// 若符合某种条件则必须重换一个map</span></span><br><span class="line">    *(start.node<span class="number">-1</span>) = <span class="built_in">allocate_node</span>();</span><br><span class="line">    __STL_TRY&#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node<span class="number">-1</span>);</span><br><span class="line">        start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">construct</span>(start.cur, t_copy);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node+<span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*(start.node<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 假如8个节点，初始状态用了3，4，5。并在后续操作中对头端插入用到了1，2</span></span><br><span class="line">    <span class="keyword">if</span>(nodes_to_add &gt; start.node - map)</span><br><span class="line">        <span class="comment">// 如果map尾端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件则必须重换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reallocate-map"><a href="#reallocate-map" class="headerlink" title="reallocate_map"></a>reallocate_map</h5><p>如果map的节点备用空间不足，则必须重新换一个map（配置更大的，拷贝原来的，释放原来的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="type">bool</span> add_at_front)&#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>; <span class="comment">// 原来的节点数</span></span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add; <span class="comment">// 现在的节点数</span></span><br><span class="line">    </span><br><span class="line">    map_pointer new_nstart; <span class="comment">// 新创建一个map</span></span><br><span class="line">    <span class="keyword">if</span>(map_size &gt; <span class="number">2</span>*new_num_nodes)&#123;</span><br><span class="line">        <span class="comment">// 如果原 map 的大小大于 2 * new_num_nodes，则可以在原有内存空间上进行调整</span></span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">            + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(new_nstart &lt; start.node)</span><br><span class="line">            <span class="built_in">copy</span>(start.node, finish.node+<span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 新的起始位置在原有内存空间的后半部分</span></span><br><span class="line">            <span class="comment">// 目的是将原有节点内容从后往前拷贝到新的位置，避免了重复的移动操作。</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start.node, finish.node+<span class="number">1</span>, new_nstart+old_num_nodes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果原 map 的大小不够容纳新节点数，需要重新分配更大的内存空间</span></span><br><span class="line">        size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 配置一块新空间，给map使用</span></span><br><span class="line">        map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把原map内容拷贝过来， [start.node, finish.node + 1)</span></span><br><span class="line">        <span class="built_in">copy</span>(start.node, finish.node+<span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        <span class="comment">// 设定新map的起始地址与大小</span></span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新设定迭代器start和finish</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque的元素操作"><a href="#deque的元素操作" class="headerlink" title="deque的元素操作"></a>deque的元素操作</h4><h5 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deque的最前端或最后端取元素，需要考虑在某种条件下，将缓冲区释放掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(finish.cur != finish.first)&#123;</span><br><span class="line">        --finish.cur;</span><br><span class="line">        <span class="built_in">destory</span>(finish.cur); <span class="comment">// 将最后元素析构</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">pop_back_aux</span>(); <span class="comment">// 释放缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有finish.cur == finish.first时才会被调用</span></span><br><span class="line"><span class="comment">// 此时该缓冲区是没有数据的，需要移除上一个缓冲区尾端的数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>()&#123;</span><br><span class="line">    <span class="built_in">deallocate_node</span>(finish.first); <span class="comment">// 释放最后一个缓冲区</span></span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);！</span><br><span class="line">    finish.cur = finish.last<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pop-front"><a href="#pop-front" class="headerlink" title="pop_front"></a>pop_front</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start.cur != start.last - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur); <span class="comment">// 析构第一个元素</span></span><br><span class="line">        ++start.cur; <span class="comment">// 调整指针，相当于排除了第一元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">pop_front_aux</span>(); <span class="comment">// 释放缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有start.cur == start.last - 1 时才会被调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>()&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(start.cur);</span><br><span class="line"><span class="built_in">deallocate_node</span>(start.first);</span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node+<span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p>清除整个deque，回到最初的状态，保留一个缓冲区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    <span class="comment">// 针对头尾以外的缓冲区，他们一定是饱和的</span></span><br><span class="line"><span class="keyword">for</span>(map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node)&#123;</span><br><span class="line">        <span class="comment">// 将缓冲区的所有元素析构</span></span><br><span class="line">        <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="comment">// 释放缓冲区内存</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start.node != finish.node)&#123;</span><br><span class="line">        <span class="comment">// 至少有头尾两个缓冲区</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, start.last);</span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur);</span><br><span class="line">        <span class="comment">// 以下释放尾缓冲区，保留头缓冲区</span></span><br><span class="line">        data_allocator::<span class="built_in">dealloate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">// 只有一个缓冲区</span></span><br><span class="line">        <span class="comment">// 只析构元素，不释放唯一的缓冲区</span></span><br><span class="line">        <span class="built_in">destory</span>(start.cur, finish.cur);</span><br><span class="line">    finish = start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除pos所指的元素， pos为清除点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 清除点之前的元素个数</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>))&#123; <span class="comment">// 清除点之前的元素比较少</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next); <span class="comment">// 就移动清除点之前的元素</span></span><br><span class="line">        <span class="built_in">pop_front</span>(); <span class="comment">// 移动完毕，去除最前一个元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 清除点之后的元素比较少</span></span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos); <span class="comment">// 移动清除点之后的元素</span></span><br><span class="line">        <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start+index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除[first, last)区间的所有元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator, last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fisrt == start &amp;&amp; last == finish)&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        difference_type n = last - first; <span class="comment">// 清除区间的长度</span></span><br><span class="line">        difference_type elems_before = first - start;<span class="comment">// 清除区间前方的元素</span></span><br><span class="line">        <span class="keyword">if</span>(elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 前方元素比较少</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start, first, last);</span><br><span class="line">            iterator new_start = start+n; <span class="comment">// 标记deque的新起点</span></span><br><span class="line">            <span class="built_in">destroy</span>(start, new_start); <span class="comment">// 将多余元素析构</span></span><br><span class="line">            <span class="comment">// 释放冗余的缓冲区</span></span><br><span class="line">            <span class="keyword">for</span>(map_poniter cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            start = new_start; <span class="comment">// 设定deque的新起点</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 清除区间后方元素比较少</span></span><br><span class="line">            <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">            <span class="comment">//iterator new_finish = first + elems_before</span></span><br><span class="line">            iterator new_finish = finish - n;</span><br><span class="line">            <span class="built_in">destroy</span>(new_finish, finish); <span class="comment">// 析构多余的元素</span></span><br><span class="line">            <span class="comment">// 释放冗余的缓冲区</span></span><br><span class="line">            <span class="keyword">for</span>(map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            finish = new_finish; <span class="comment">// 设定deque的新尾点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在positino插入一个元素，值为x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(position.cur == start.cur)&#123;</span><br><span class="line">        <span class="comment">//插入点在最前端</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position.cur == finish.cur)&#123;</span><br><span class="line">        <span class="comment">//插入点在最后端</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x); <span class="comment">// 交给insert_aux去做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x)&#123;</span><br><span class="line">    difference_type index = pos - strat; <span class="comment">// 插入点之前的元素个数</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="built_in">size</span>() / <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 在插入点之前的元素个数比较少</span></span><br><span class="line">        <span class="comment">// 在最前端加入一个与第一元素相同值的元素</span></span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        <span class="comment">// 标示记号，进行元素移动</span></span><br><span class="line">        iterator front1 = start;</span><br><span class="line">        ++front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++front2;</span><br><span class="line">        pos = start+index; </span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++pos1; <span class="comment">// 该位置后移一位才是真正插入点，因为最前边新加了一个元素</span></span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1); <span class="comment">// 元素移动</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入点之后的元素个数比较少</span></span><br><span class="line">        <span class="comment">// 在尾端加入与最后元素同值的元素</span></span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        <span class="comment">// 标示记号，进行元素移动</span></span><br><span class="line">        iterator back1 = finish;</span><br><span class="line">        --back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        --back2;</span><br><span class="line">        pos = start + index; <span class="comment">// 此时该位置没有发生变化</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​先进后出的数据结构，允许新增元素、移除元素、取得最顶端元素。不允许有遍历行为,没有迭代器</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="（1）以deque为底部结构并封闭头端开口"><a href="#（1）以deque为底部结构并封闭头端开口" class="headerlink" title="（1）以deque为底部结构并封闭头端开口"></a>（1）以deque为底部结构并封闭头端开口</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference  reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下完全利用Sequence c的操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="comment">// deque是两头可进出，stack末端进，末端出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, </span><br><span class="line">                <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, </span><br><span class="line">                <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="（2）以list作为底层容器"><a href="#（2）以list作为底层容器" class="headerlink" title="（2）以list作为底层容器"></a>（2）以list作为底层容器</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file : 4stack-test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span> , list&lt;<span class="type">int</span>&gt; &gt; istack ;</span><br><span class="line">    istack.<span class="built_in">push</span> (<span class="number">1</span>);</span><br><span class="line">istack.<span class="built_in">push</span> (<span class="number">3</span>);</span><br><span class="line">    istack.<span class="built_in">push</span> (<span class="number">5</span>);</span><br><span class="line">    istack.<span class="built_in">push</span> (<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; istack.<span class="built_in">size</span> ( ) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; istack.<span class="built_in">top</span> ( ) &lt;&lt; endl;  <span class="comment">// 7</span></span><br><span class="line">    </span><br><span class="line">istack.<span class="built_in">pop</span>( );</span><br><span class="line">    cout &lt; istack.<span class="built_in">top</span> ( ) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    istack.<span class="built_in">pop</span>( );</span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>( ) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    istack.<span class="built_in">pop</span>( ); </span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">top</span>( ) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">size</span>( ) &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>​先进先出的数据结构，允许新增元素、移除元素、从最底端加入元素、取得最顶端元素，不允许遍历，没有迭代器</p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="以deuqe为底部结构并封闭其底端的出口和前端的入口"><a href="#以deuqe为底部结构并封闭其底端的出口和前端的入口" class="headerlink" title="以deuqe为底部结构并封闭其底端的出口和前端的入口"></a>以deuqe为底部结构并封闭其底端的出口和前端的入口</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference  reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="comment">// deque是两头可进出，queue末端进，前端出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, </span><br><span class="line">                <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, </span><br><span class="line">                <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="以list作为queue的底层容器"><a href="#以list作为queue的底层容器" class="headerlink" title="以list作为queue的底层容器"></a>以list作为queue的底层容器</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file : 4stack-test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span> , list&lt;<span class="type">int</span>&gt; &gt; istack ;</span><br><span class="line">    queue.<span class="built_in">push</span> (<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span> (<span class="number">3</span>);</span><br><span class="line">    queue.<span class="built_in">push</span> (<span class="number">5</span>);</span><br><span class="line">    queue.<span class="built_in">push</span> (<span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; queue.<span class="built_in">size</span> ( ) &lt;&lt; endl;  <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; queue.<span class="built_in">front</span> ( ) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">istack.<span class="built_in">pop</span>( );</span><br><span class="line">    cout &lt; istack.<span class="built_in">front</span> ( ) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    istack.<span class="built_in">pop</span>( );</span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">front</span>( ) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    istack.<span class="built_in">pop</span>( ); </span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">front</span>( ) &lt;&lt; endl; <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; istack.<span class="built_in">size</span>( ) &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="heap（隐式表述：implicit-representation"><a href="#heap（隐式表述：implicit-representation" class="headerlink" title="heap（隐式表述：implicit representation)"></a>heap（隐式表述：implicit representation)</h2><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p>​heap不属于STL容器组件，binary max heap适合作为priority queue的底层机制</p><p>​根据元素排序，heap可分为max-heap和min-heap</p><p>​用array来储存所有节点，0位置保留（或设为最大值或最小值）。当complete binary tree的某个节点位于array的i处时，左节点位于array的2i处，右节点位于array的2i+1处，父节点位于i&#x2F;2，取整数。这种以array表述tree的方式称为隐式表述法（implicit reprentation)。以下算法0索引位置使用了，所以上述找寻左右节点和父节点的方法不适用，左节点2<em>i+1，右节点2</em>i+2，父节点(i-1)&#x2F;2</p><h5 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h5><h6 id="（1）push-heap算法"><a href="#（1）push-heap算法" class="headerlink" title="（1）push_heap算法"></a>（1）push_heap算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接收两个迭代器，用来表示一个heap底部容器（vector）的头尾，并且新元素已经插入到队尾</span></span><br><span class="line"><span class="comment">// 如果不满足这两个条件，push_heap的执行结果未可预期</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用此函数前，新元素已经位于底部容器的最尾端</span></span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __push_heap_aux(RandomAccessIterator, first, RandomAccessIterator, last</span><br><span class="line">                           Distance*, T*)&#123;</span><br><span class="line">    <span class="comment">// 根据implicit representation heap结构的特性：新值必须位于最尾端</span></span><br><span class="line">    <span class="comment">// 容器的最尾端 (last - first) - 1</span></span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __push_heap(RandomAccessIterator, first, Distance holeIndex, </span><br><span class="line">                           Distance topIndex, T value)&#123;</span><br><span class="line"> <span class="comment">// 找出父节点</span></span><br><span class="line">    Distance parent = (holeIndex<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(holeIndex &gt; topIndex &amp;&amp; *(first+parent) &lt; value)&#123;</span><br><span class="line">        <span class="comment">// 当未达到顶端，且父节点的值小于新值</span></span><br><span class="line">        *(first+holeIndex) = *(first+parent);</span><br><span class="line">        holeIndex = parent; <span class="comment">// 新值提升至父节点</span></span><br><span class="line">        parent = (holeIndex<span class="number">-1</span>) / <span class="number">2</span>; <span class="comment">// 更新新值的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    *(first+holeIndex) = value; <span class="comment">// 完成插入操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/15/WgUhLjXOiR3Fr9d.jpg" alt="STL_heap_push_heap算法.jpg"></p><h6 id="（2）pop-heap算法"><a href="#（2）pop-heap算法" class="headerlink" title="（2）pop_heap算法"></a>（2）pop_heap算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数接收两个迭代器。用来表现一个heap底部容器（vector）的头尾</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>&#123;</span><br><span class="line">__pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据implicit representation heap的次序特性，pop操作的结果应该是底部容器的第一个元素</span></span><br><span class="line"><span class="comment">// 因此首先设定预调整值为尾值，然后将首值调至尾节点（将迭代器result设为last-1）</span></span><br><span class="line"><span class="comment">// 然后重整[first, last-1)，使其称为一个合格的heap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*)&#123;</span><br><span class="line">    __pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator, last, </span><br><span class="line">                      RandomAccessIterator result, T value, Distance*)&#123;</span><br><span class="line">    *result = *first;<span class="comment">// 设定尾值为首值，之后可用pop_back()取出尾值</span></span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last-first), value); <span class="comment">// 重新调整heap，洞号为0（即树根处）需要调整的值为原尾值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">                  Distance len, T value)&#123;</span><br><span class="line">    Distance topIndex = holeIndex;</span><br><span class="line">    Distance secondChild = <span class="number">2</span>*holeIndex + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">while</span>(secondChild &lt; len)&#123;</span><br><span class="line">        <span class="comment">// 比较洞节点的左右两个节点，以secondChild代表较大子节点</span></span><br><span class="line">        <span class="keyword">if</span>(*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">            secondChild--;</span><br><span class="line">        <span class="comment">// 令较大值为洞值，再令洞号下移至较大子节点处</span></span><br><span class="line">        *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">        holeIndex = secondChild;</span><br><span class="line">        <span class="comment">// 找出新洞的右子节点</span></span><br><span class="line">        secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(secondChild == len)&#123; <span class="comment">// 没有右子节点，只有左子节点</span></span><br><span class="line">        <span class="comment">// 令左子节点为洞值，再令洞号下移至左子节点处</span></span><br><span class="line">        *(first+holeIndex) = *(first+(secondChild<span class="number">-1</span>));</span><br><span class="line">        holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// *(first+holeIndex) = value和下方等价</span></span><br><span class="line">    __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/15/2CgEoqeDf6pTYN5.jpg" alt="STL_heap_pop_heap算法.jpg"></p><h6 id="（3）sort-heap算法"><a href="#（3）sort-heap算法" class="headerlink" title="（3）sort_heap算法"></a>（3）sort_heap算法</h6><p>​每次pop_heap可将最大值移至尾端，每次操作范围从后向前缩减一个元素，整个程序执行完毕将有一个递增序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomAccessIterator&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(last - first &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pop_heap</span>(first, last--);<span class="comment">//每次执行，操作范围退缩一格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/15/Te8YpsbLzliUh92.jpg" alt="STL_heap_sort_heap算法.jpg"></p><p><img src="https://s2.loli.net/2023/08/15/5kftKoXObrdzHuJ.jpg" alt="STL_heap_sort_heap算法续.jpg"></p><h6 id="（4）make-heap算法"><a href="#（4）make-heap算法" class="headerlink" title="（4）make_heap算法"></a>（4）make_heap算法</h6><p>将一段现有数据转化为一个heap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将[first, last)排序为一个heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>&#123;</span><br><span class="line">__make_heap(fisrt, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">                T*, Distance*)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 如果长度为0或1不用排序</span></span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(fisrt+parent)));</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 走完根节点，就结束</span></span><br><span class="line">        parent--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>​允许加入新元素、移除旧元素、审视元素值等功能，允许子啊底端加入元素，并从顶端取出元素。</p><h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><p>​以底部容器为根据，再加上heap的处理规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequeue c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>():<span class="built_in">c</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span>: c(), comp(x)&#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下用到的make_heap(),push_heap(),pop_heap()都是泛型算法</span></span><br><span class="line">    <span class="comment">// 注意，任意一个构造函数都立刻于底层容器内产生一个implicit representation heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x)</span><br><span class="line">        : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x)&#123;</span><br><span class="line">            <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">    <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last)</span><br><span class="line">        : <span class="built_in">c</span>(first, last)&#123;</span><br><span class="line">            <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">// push_back是泛型算法，先利用底层容器的push_back()将新元素推入末端，再重排heap</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="comment">// pop_heap是泛型算法，从heap内取出一个元素，它并不是将元素真正弹出，</span></span><br><span class="line">            <span class="comment">// 而是重排heap，然后以底层容器pop_back()取出被弹出的元素</span></span><br><span class="line">            <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>​slist是一个单向链表， 不提供push_back()，只提供push_front()，还提供了insert_after()和erase_after()</p><h5 id="slist的节点"><a href="#slist的节点" class="headerlink" title="slist的节点"></a>slist的节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的节点基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node_base</span>&#123;</span><br><span class="line">__slist_node_base* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单向链表的节点结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node</span> : <span class="keyword">public</span> __slist_node_base&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局函数：已知某一节点，插入新节点到这个节点的后边</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link(__slist_node_base* prev_node,</span><br><span class="line">                                            __slist_node_base* new_node)&#123;</span><br><span class="line">    <span class="comment">// 令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局函数：单向链表的大小（元素个数）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __slist_size(__slist_node_base* node)&#123;</span><br><span class="line">    <span class="type">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; node != <span class="number">0</span>; node = node-&gt;next)</span><br><span class="line">        ++result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="slist的迭代器"><a href="#slist的迭代器" class="headerlink" title="slist的迭代器"></a>slist的迭代器</h5><p><img src="https://s2.loli.net/2023/08/15/DbgWcjHsmSPqAlL.jpg" alt="STL_slist_迭代器.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slist的迭代器基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag itrerator_category; <span class="comment">// 注意， 单向</span></span><br><span class="line">    </span><br><span class="line">    __slist_node_base* node; <span class="comment">// 指向节点基本结构</span></span><br><span class="line">    __slist_iterator_base(__slist_node_base* x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123; node = node-&gt;next; &#125;<span class="comment">// 前进一个节点</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == x.node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node != x.node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slist的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator</span> : <span class="keyword">public</span> __slist_iterator_base&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt;    iterator;  </span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator&lt;T, Ref, Ptr&gt;     self;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line">    </span><br><span class="line">    __slist_iterator(list_node* x) : __slist_iterator_base(x)&#123;&#125;</span><br><span class="line">    <span class="comment">// 调用slist&lt;T&gt;::end()会造成__slist_itreator(0),于是调用上述函数</span></span><br><span class="line">    __slist_iterator() : __slist_iterator_base(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    __slist_iterator(<span class="type">const</span> iterator&amp; x) : __slist_iterator_base(x.node)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((list_node*)node)-&gt;data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="built_in">incr</span>(); <span class="comment">// 前进一个节点</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">incr</span>(); <span class="comment">// 前进一个节点</span></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="slist的数据结构"><a href="#slist的数据结构" class="headerlink" title="slist的数据结构"></a>slist的数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist&#123;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterater;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_node_base list_node_base;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iterator_base iterator_base;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> list_node* <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 配置空间</span></span><br><span class="line">        list_node* node = list_node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        __STL_TRY&#123;</span><br><span class="line">            <span class="built_in">construct</span>(&amp;node-&gt;data, x); <span class="comment">// 构造元素</span></span><br><span class="line">            node-&gt;next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __STL_UNWIND(list_node_allocator::<span class="built_in">deallocate</span>(node));</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span></span>&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;node-&gt;data); <span class="comment">// 析构元素</span></span><br><span class="line">        list_node_allocator::<span class="built_in">deallocate</span>(node); <span class="comment">// 释放空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list_node_base head; <span class="comment">// 头部，不是指针，是实物</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">slist</span>() &#123; head.next = <span class="number">0</span>; &#125;</span><br><span class="line">    ~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __slist_size(head.next); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head.next == <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个slist互换，只需要将head交换互指即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span></span>&#123;</span><br><span class="line">        list_node_base* tmp = head.next;</span><br><span class="line">        head.next = L.head.next;</span><br><span class="line">        L.head.next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ((list_node*)head.next)-&gt;data; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;</span><br><span class="line">        __slist_make_link(&amp;head, <span class="built_in">create_node</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list_node* node = (list_node*) head.next;</span><br><span class="line">        head.next = node-&gt;next;</span><br><span class="line">        <span class="built_in">destroy_node</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序列式容器分类&quot;&gt;&lt;a href=&quot;#序列式容器分类&quot; class=&quot;headerlink&quot; title=&quot;序列式容器分类&quot;&gt;&lt;/a&gt;序列式容器分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/16/ybceWa2J5</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/08/07/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2023/08/07/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</id>
    <published>2023-08-07T06:11:05.948Z</published>
    <updated>2023-07-27T02:41:22.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件是对I/O设备的抽象</span><br><span class="line">虚拟内存是对主存和I/O设备的抽象（程序存储器）</span><br><span class="line">进程是对处理器，主存和I/O设备的抽象（一个正在运行的程序）</span><br><span class="line">虚拟机是对整个计算机的抽象（操作系统，处理器，主存，I/O设备）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式和位级运算</span><br><span class="line">1.逻辑表达式认为非0的参数都表示TRUE，按位运行只有参数为0或1才和逻辑运算有相同的行为</span><br><span class="line">2.如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值</span><br></pre></td></tr></table></figure><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><h5 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟页（VP），存储在磁盘中。未分配，已缓存，未缓存</span><br><span class="line">物理页（PP），缓存在DRAM中，虚拟页已缓存的数据出现在物理页中</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230726171840605.png" alt="image-20230726171840605"></p><h5 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.内存隔离</span><br><span class="line">每个进程都有自己独立的虚拟地址空间，使进程直接彼此隔离</span><br><span class="line">2.内存访问权限</span><br><span class="line">虚拟内存运行操作系统为每个页面设置不同的访问权限，如只读、只写、执行等</span><br><span class="line">3.页面错误处理</span><br><span class="line">在虚拟内存中，当一个进程访问未加载到物理内存或不存在的页面时，产生页面错误，操作系统会捕获这些错误并采取相应的措施</span><br><span class="line">4.内存限制和资源管理</span><br><span class="line">虚拟内存允许操作系统对进程分配的虚拟地址空间进行精确的管理。如设定地址空间的大小、内存分配和回收等。避免进程占用过多的内存资源</span><br></pre></td></tr></table></figure><h5 id="页框，页面，页框号"><a href="#页框，页面，页框号" class="headerlink" title="页框，页面，页框号"></a>页框，页面，页框号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页框：将内存空间分为一个个大小相等的分区，每个分区就是一个页框</span><br><span class="line">页面：将进程的逻辑地址空间分为和页框大小相等的一个个部分，每个部分称为页或页面</span><br></pre></td></tr></table></figure><h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VM需要判断一个VP是否缓存在DRAM中的某个地方。</span><br><span class="line">如果是，还需要判断在哪个PP中。</span><br><span class="line">如果不命中，系统必须判断这个VP存放在磁盘哪个位置，在物理内存中选择一个牺牲页，将VP从磁盘复制到DRAM中，替换这个牺牲页</span><br></pre></td></tr></table></figure><p>​1.一个进程对应一张页表</p><p>​2.进程的每个页面对应一个页表项</p><p>​3.每个页表项又页号和块号组成</p><p>​4.页表记录进程页面和实际存放的内存快之间的映射关系</p><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基于32位的地址空间，一个页面4KB，一个PTE4B，则一个进程有4MB的页表驻留在主存中</span><br><span class="line"></span><br><span class="line">使用分级页表：</span><br><span class="line">一级页表每个页表项负责映射这个虚拟地址空间中一个4MB的片，每一片是由1024个连续页面组成</span><br><span class="line">二级页表每个页表项负责映射一个4KB的虚拟内存页面</span><br><span class="line">使用4字节的PTE，一级页表和二级页表都是一个页面的大小</span><br><span class="line"></span><br><span class="line">这种方法从两个方面减少了内存要求：</span><br><span class="line">1.如果一级页表的一个PTE是空的，对应的二级页表不会存在</span><br><span class="line">2.只有一级页表总是在主存中，经常使用的二级页表才会缓存在主存中</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727093639086.png" alt="image-20230727093639086"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深入理解计算机系统&quot;&gt;&lt;a href=&quot;#深入理解计算机系统&quot; class=&quot;headerlink&quot; title=&quot;深入理解计算机系统&quot;&gt;&lt;/a&gt;深入理解计算机系统&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
</feed>
